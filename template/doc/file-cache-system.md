<!-- TOC -->

- [1. 问题](#1-%E9%97%AE%E9%A2%98)
- [2. 思路](#2-%E6%80%9D%E8%B7%AF)
- [3. 解决方案](#3-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88)
    - [3.1. 梳理需求](#31-%E6%A2%B3%E7%90%86%E9%9C%80%E6%B1%82)
    - [3.2. 封装接口](#32-%E5%B0%81%E8%A3%85%E6%8E%A5%E5%8F%A3)
    - [3.3. 技术调研](#33-%E6%8A%80%E6%9C%AF%E8%B0%83%E7%A0%94)
    - [3.4. 边界分析](#34-%E8%BE%B9%E7%95%8C%E5%88%86%E6%9E%90)
    - [3.5. 实现拆解](#35-%E5%AE%9E%E7%8E%B0%E6%8B%86%E8%A7%A3)
    - [3.6. 测试](#36-%E6%B5%8B%E8%AF%95)
- [4. 结论](#4-%E7%BB%93%E8%AE%BA)
- [5. 展望](#5-%E5%B1%95%E6%9C%9B)
- [6. 文献](#6-%E6%96%87%E7%8C%AE)

<!-- /TOC -->



------------------------------------------------------------------------------

# 1. 问题

分布式任务系统，在某个执行服上，会接收任务发布服的任务，并从任务发布服接收执行所需要的数据，比如exe程序、exe程序的输入文件等等。

如果不同任务，执行需要用到相同的文件，如exe程序相同，如果每次执行任务，都重复获取exe，会浪费较多的时间，也会浪费网络带宽，为此实现文件缓存系统。

在接收到一个文件之后，会临时缓存在本地，在每次接收任务，分析执行需要的数据时，如果是文件，可以先查询文件缓存系统，看是否已经存在，存在，并且能够匹配上（md5相同，文件名相同，文件大小相同...），那么，直接采用已有文件。




------------------------------------------------------------------------------

# 2. 思路

* 梳理需求
* 封装接口
* 实现分析
* 技术调研
* 边界分析
* 实现拆解
* 测试



------------------------------------------------------------------------------

# 3. 解决方案

## 3.1. 梳理需求

* 需要有一个索引文件，记录当前文件缓存系统中的所有信息
  * 支持索引文件的启动加载、停止时保存
  * 索引文件启动时候，和现有本地缓存文件进行核对，维持一致性，清理所有不一致的文件
  * 单个文件索引的格式：md5，文件名，大小，上次使用时间，文件状态-是否正常

* 文件目录设计
  * file-cache-system                               根目录文件夹
  * file-cache-system/index.json                    索引文件
  * file-cache-system/files                         所有文件
  * file-cache-system/files/xx                      xx是文件的md5码的前两位，参考.git\objects、Unity\Library\Artifacts
  * file-cache-system/files/xx/yyyyyyyyy            yyyyyyyyy，md5码的后面位数，Unity是完整的md5文件名，相比来说，更倾向于git的设计，只存md5码后面的位数，一方面，减少文件长度；一方面，也方便后续排序查看文件
  * file-cache-system/download-temp/xxyyyyyyyyy     下载的临时文件夹，等下载结束时候，移到正式目录中，即files文件夹下（下载过程可以在外部实现）

* 检查文件：已知文件的名字、md5、大小，判断缓存系统中是否存在相同，并且文件状态处于正常状态

* 空间大小检查流程：检查当前缓存系统文件总的大小是否已经超出上限，如果超出上限，需要考虑清理最久未使用的文件
  * 维护一个队列，队首为最久未使用文件，队尾为最近使用的文件
  * 新的文件放到队尾
  * 如果使用了已有的文件，将其移到队尾
  * 如果空间不足，移除队首文件，直到空间足够放下新的文件(确保缓存系统使用空间始终不大于设置的总空间)

* 启动流程
  * 加载索引文件
  * 检查，核对索引文件和本地缓存文件
  * 清理download-temp文件夹下的文件

* 保存文件
  * 保存文件，可能文件已经存在，需要删除已存在文件
  * 保存文件，需要同时新增索引信息
  * 添加文件，先新增文件，在添加索引信息（在启动时，根据索引文件清理文件）
  * 保存文件前，触发空间大小检查流程
  * 保存可能失败，正好被使用，需要设置索引文件状态（概率较小，除非两个MD5码相同，或是清理的时候，刚好文件被使用）

* 加载文件
  * 检查文件是否正常
  * 文件状态异常，返回报错
  * 正常加载文件，返回文件，支持用with调用加载接口

* 删除文件
  * 删除文件，先删除索引信息，再删除文件（在启动时，根据索引文件清理文件）
  * 删除文件，需要同时删除索引信息
  * 删除可能失败，需要记录log（刚好正在被使用）

* 修改文件
  * 先干掉索引，再删除文件，再增加文件，最后补上索引

* 停止流程
  * 保存索引文件
  * 清理download-temp文件夹

## 3.2. 封装接口

FileCacheSystem
    Init(szFullDir)
    _LoadIndex(szRelPath)
    _SaveIndex(szRelPath)
    SaveFile(szMd5, szFileName, nSize)
    LoadFile(szMd5, szFileName, nSize)
    UseFile(szMd5, szFileName, nSize)
    _CheckFile(szMd5, szFileName, nSize)
    Destroy()
    _ClearCache(nNeedSize)

## 3.3. 技术调研
* 获得文件大小、文件md5码
  * os.path.getsize()
  * common.md5.GetFileMD5()
* md5码作为文件名，是否ok，会不会太长
  * 32位，还行，没毛病
* python空间清理算法
  * 
* 加载文件，json模块接口调研
  * json.load(fp)
  * json.dump(dict, fp)
* 删除文件接口，及删除失败报错信息
  * common.util.RemoveFileDir

## 3.4. 边界分析
* 索引文件和缓存文件系统不一致
* 删除、保存、检查文件等执行会出现异常，需要考虑：直接返回报错，此次任务失败
* 加载索引文件失败，直接crash
* 保存索引文件失败，在启动的时候做一致性检查

## 3.5. 实现拆解


## 3.6. 测试
* 新增文件
  测试启动加载，新增保存，停止保存索引
  * 启动
  * 新增文件
  * 停止

* 文件空间不足，自动清理流程
  * 调小空间，然后加载文件，触发清理流程

* 索引文件和缓存文件不一致情况

* 索引文件格式异常容错，处理


------------------------------------------------------------------------------

# 4. 结论




------------------------------------------------------------------------------

# 5. 展望




------------------------------------------------------------------------------

# 6. 文献


